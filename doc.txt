1. При использовании CSS-правила table-layout для таблицы обязательно указание ширины (100%)
2. Форма записи для присваивания свойств нескольких классов: <div class="one two"> вместо <div class="one" class="two">

3. Значение свойства nodeName регистрозависимо, всегда переводится в uppercase


1. Отображение всех записей, получаемых из заглушки, посредством JavaScript (относится к методу RenderAirData представления AircraftTechView). +
2. Выделение одной, нескольких или всех записей (radio button) +
3. Вывод окна подтверждения для удаления строк с указанием кол-ва строк, удаление записей +/-
4. Сохранение новой записи в заглушке при добавлении и обновление списка записей +
5. Подстановка в поля модального окна редактирования записи -
6. Добавление правил фильтров (одновременная фильтрация всех строк) -

7. Валидация данных, вводимых в поля, при подтверждении добавления или редактирования
8. Вывод модального окна (предупреждение), если не выбраны строки для редактирования, если не выбраны строки для удаления

9. Данные - заглушка для рейсов +
10. frontend миниатюры самолета (с указанием занятых мест)

11. Разделение init_table на: view, controller +/-
12. Заменить вложенные forEach на более простой способ перебора вложенных узлов + (forEach используется для перебора массивов, for - для перебора полей объектов, forEach используется, когда у объекта есть итератор)

Frontend проверен в браузерах: Chrome 68.0, Firefox 61.0.2



Чтобы подставить в поля модального окна данные, нужно разнести существующие скрипты согласно объектной модели

вызовы в функции ready() ---> initTools(); initTableContent(); resizeText(); +

initTools(); initTableContent(); относятся к TableView +
resizeText(); относится к DetailedView(); т.к. только в этой части представления есть поля, которым необходимо изменение размеров +
функция resizable_text.js resize_text() - влияет только на представление, выносится в DatailedView +

resizable.js либо удаляется, т.к. в проекте больше нет блочной верстки таблицы, либо адаптируется под <tr><td> предсатвление + (удаляется)

все вызовы относятся к отрисовке представления страницы, поэтому все вызовы заменяются на создание 1 экземпляра View,
который в конструкторе вызовет эти функции +

View представляет из себя отдельный объект AppView, который отвечает за отрисовку всего экрана +
Любая из страниц содержит области для: вывода ссылок, фильтры, талицы с данными, детального просмотра + (создание общего View сопровождается вызовом методов для поэтапной отрисовки частей страницы)

AppView не может напрямую записывать данные в экземляры модели, вместо этого она может вызвать соответствующий метод
в AirplaneController или другом EntityController +

т.е. для того, чтобы достичь такого разделения, необходимо разделить функции, обращения к элементам DOM, обращения к экземплярам моделей
между AppView и AirplaneController
т.е. резделить код скриптов table_init.js   resizable_text.js   modal_window.js +/-




функции table_init
setContext() - определяет привязку данных по содержимому блока screen_header +
привязка к данным в контроллере

initHeader() - рендеринг названия полей в заголовки столбцов таблиц +
часть функции, отвечающая за добавление элементов, остается во View,
часть функции, отвечающая за перебор полей, сравнение имен полей модели и объекта из БД-заглушки, изменение данных в объектах, переносится в Controller

    dataKeys.forEach(function(key) {
        if (dataContext.enum_fields[key].name != "id")
            th_td("th", tr1, dataContext.enum_fields[key].name);
    }); 

initRecords() - рендеринг данных в ряды таблицы +
часть функции во View
часть функции в Controller

initTableContent() - заполнение таблицы в первый раз при загрузке страницы +
остается во View

new_line(table) tr(table) th_td(table_tag, tr, html, tag, src, type, name, id) +
new_line больше не используется, т.к. блочная таблица была заменена на табличное представление

markRecord() markRecords() +
остются во View

deleteRec() deleteRecs() +/-
обращение к заглушке выносится в Controller
удаление записей реализовано на стороне View
на стороне Controller удаление записей из объекта в процессе реализации

saveRec() 
остается во View, но переносятся из table в ModalView

pushData()
переносится в Controller из TableView

 highlightRow() +
 остается в TableView
 
 
 как это поможет в добавлении валидации в проект?
 валидация требует обращения только к тем данным, которые находятся непосредственно на странице, т.е. использует только View (не записывает данные)
 
 упрощение кода поможет проще и быстрее внедрить валидацию
 проверка происходит при сохранении или изменении записи
 используются типы данных объектов
 валидация хоть и является частью сохранения, но выносится в отдельную функцию
 валидируемые типы данных: числовой, текстовый, дата, изображение
 валидация данных изменяет View (добавляет надписи, в каких полях допущена ошибка)
 
 
 
 
 
 функции modal_window -> ModalView.js
 fillModal() - обращение к контексту в начале функции выносится в Controller
 - определение выполняемого действия остается
 - навешивание обработчика на закрытие окна выносится в отдельную функцию (чтобы не перегружать тело функции)
 - отображение окна
 - вызов пересчета координат положения окна
 остается во View
 
 renderCloseButton() - обращение из displayElements() переносится в fillModal()
 остается во View
 
 confirmRemove() - подтверждение удаления элемента(ов)
 остается во View
 
 displayElements() - рендеринг UI для разных типов данных согласно модели объекта (поддерживается text, numeric, image)
 остается во View для модального окна 
 
 modalCoords() - расчет координат положения модального окна
 остается во View для модельного окна
 
 initTools() - инициализирует обработчики на элементах графического интерфейса для редактирования
 - относится ко View, но не к модальному окну
 

 View не должно содержать переменных data, dataContext и прочих контекстов, т.к.
 View ничего не известно о моделях и данных в этих моделях
 
 
 Непонятно, как использовать typeof для объектов, создаваемых через функциональный стиль наследования
 Это будет необходимо, когда все приложение будет преставлять собой 4 возможных View
 
 1 - представление с таблицей данных и детальным просмотром объекта (для авиатехники, списка пассажиров, списка сотрудников)
 2 - представление с таблицей данных и 3-мя возмозжными частичными представлениями (маркеры авиатехники, детальный просмотр, схема мест пассажирского самолета)  
 3 - представление с графиком рейсов и детальным просмотром объекта 
  

 Как передавать список полей из контроллера в представление?
 - все типы данных хранятся в модели
 - представление знает, как отображать каждый из типов
 - контроллер знает, как получить доступ к моделям и передать данные представлению
 - отображение таблицы и окна редактирования отличаются тем, что в окне редактирования сразу отображается имя поля, учитывается тип поля, отображается элемент для редактирования поля
 в таблице только верхняя строка использует тип и имя полей

field = {
    _number = {
    
    }  
};


При редактировании записи в модальном окне, как и при выводе данных в области детального просмотра, все поля и значения дублируются из общей таблицы

Это значит, что нужна функция для извлечения в объект всех полей активной записи и генерации события обновления зависимых частей представления
Выбор осуществляется также через checkbox
Запись сохраняется по ID в родительском tr - теге
Имена полей извлекаются из заголовка таблицы 


Страница настроек приложения
- сохранять последний примененный фильтр
- интервал автоматического обновления строк в таблице
- обновлять строки автоматически или уведомлять об изменениях
- вывод в таблицах только статической информации о сущностях/динамической/комбинированной. Статические - характеристики, динамические - обслуживающий экипаж, текущее расположение
- автоматически выбирать первую запись в таблице




Преимущества использования MVC для frontend - приложения:
Абстрагирование всех обращений к данным

context = document.getElementById("screen_header");
context = context.innerHTML;
//перебор в цикле осуществляется по ключу
for (var key in dataDictionary) {
    if (key == context)
        context = dataDictionary[key];
}


keys = this.controller.getDataKeys();




Упрощение циклического вывода графических элементов fontend - приложения

function deleteRec() {
    rows = document.getElementsByTagName("tr");

    for (var mark in marked) {
        var d;
        for (var t = 0; t < rows.length; t++) {
            //for (row in rows) {
            if (rows[t] != "length" && rows[t] != "item" && rows[t] != "namedItem")
                if (rows[t].getAttribute("id") == marked[mark]) {
                    d = rows[t];
                    d.remove();
                    //сместиться назад
                    t = 0;
                    //rows = document.getElementsByTagName("tr");
                    marked.splice(marked.indexOf(marked[mark]), 1);
                }
        }

    }
}


function deleteRec() {
    for (var mark of marked) {
        for (var row of byTg("tr")) {
            if (row.getAttribute("id") == mark) {
                row.remove();
                marked.splice(marked.indexOf(mark), 1);
                //повторный вызов
                deleteRec();
                return;
            }
        }
    }
}


Замена сложных для восприятия 3-уровневых вложений for, foreach на стороне представления на циклы с максимальным числом вложений 2
Замена оператора "for in" на, "for of" для прямой работы со значением в цикле, а не с его индексом


function markRecords() {
    checked = this.checked;
    if (checked) {


        //перебор tr в table
        for (var node in table.rows) {
            node = table.rows[node];
            //перебор childNodes в tr
            for (var cell in node.childNodes) {
                //перебор childNodes в tr
                cell = node.childNodes[cell];
                for (var child in cell.childNodes) {
                    child = cell.childNodes[child];
                    if (child.nodeName == "INPUT" && child.getAttribute("name") == "select_single") {
                        child.checked = checked;
                        marked.push(node.getAttribute("id"));
                    }
                }
            }
        }


    } else {
        marked = [];

        for (var node in table.rows) {
            node = table.rows[node];
            for (var cell in node.childNodes) {
                cell = node.childNodes[cell];
                for (var child in cell.childNodes) {
                    child = cell.childNodes[child];
                    if (child.nodeName == "INPUT" && child.getAttribute("name") == "select_single") {
                        child.checked = checked;
                    }
                }
            }
        }


    }

}



 
function markRecords() {
    checked = this.checked;

    nodes = getTableNodes();
    nodes.forEach(function(child) {
        if (child.nodeName == "INPUT" && child.getAttribute("name") == "select_single") {
            child.checked = checked;
            if (checked) {
                marked.push(node.getAttribute("id"));
            } else {
                marked = [];
            }
        }
    });
}

function getTableNodes() {
    nodes = [];
    for (var row of that.table.rows) {
        for (var cell of row.childNodes) {
            for (var child of cell.childNodes)
                nodes.push(child);
        }
    }
    return nodes;
}



Изменение данных об авиаединице:
  -выбор действия над единицей
  -добавление новой единицы -> ввод данных
  -редактирование существующей единицы -> редактирование данных
  -удаление существующей единицы -> удаление записи
  
  
  
При обходе содержимого объектов операторы: for in, for of ведут себя по-разному,
если необходимо осуществить обход перечислимых полей объекта

for in работает корректно с обычными {} JavaScript,
for of подразумевает передачу в качестве объекта массива

getElementById() не работает при вызове метода в контексте отдельного узла, т.е.
метод работает только при контексте document
Для решения этой проблемы существует метод querySelector()